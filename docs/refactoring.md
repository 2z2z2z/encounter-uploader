# План финального рефакторинга level-system-v2

**Шаг 31 из общего плана реализации новой архитектуры**

## Правила выполнения

- ✅ **Пошаговое выполнение**: каждый пункт выполняется последовательно
- ✅ **Отметка прогресса**: после завершения пункта ставится ✅ в чекбокс
- ✅ **Проверка качества**: после каждого этапа запускать ESLint и проверять функциональность
- ✅ **Дублирование и переиспользование**: в некоторых местах может встречаться дублирование компонентов и кода, это нормально для контрол-элементов, полей и т.д.
- ✅ **Обязательность**: слишком сильно оптимизировать и рефакторить не требуется из-за опасения поломать то, что уже работает. Только критические замечания. Ты не обязан вносить правки в рамках каждого шага.

---

## 1. Анализ кодовой базы level-system-v2

### ✅ 1.1 Удаление неиспользуемых ресурсов
- ✅ Поиск неиспользуемых импортов в файлах level-system-v2
- ✅ Удаление неиспользуемых переменных и функций
- ✅ Проверка неиспользуемых TypeScript типов

### ✅ 1.2 Проверка соответствия принципам SOLID
- ✅ Single Responsibility: каждый компонент имеет одну ответственность
- ✅ Open/Closed: возможность расширения без модификации
- ✅ Liskov Substitution: корректная типизация и наследование
- ✅ Interface Segregation: интерфейсы не перегружены
- ✅ Dependency Inversion: зависимость от абстракций, не от конкретики

---

## 2. Зачистка комментариев и временного кода

### ✅ 2.1 Поиск и удаление TODO/временных решений
- ✅ Очистка неактуальных комментариев
- ✅ Поиск комментариев "// TODO: будет реализовано в шаге X"
- ✅ Удаление комментариев с упоминанием конкретных шагов плана
- ✅ Проверка всех "TODO", "FIXME", "HACK" комментариев
- ✅ Удаление fallback решений и заглушек

### ✅ 2.2 Оптимизация комментариев
- ✅ Удаление избыточных комментариев (очевидный код)
- ✅ Сохранение только полезных комментариев для сложной логики
- ✅ Проверка актуальности оставшихся комментариев

---

## 3. Проверка независимости архитектур

### ✅ 3.1 Проверка импортов
- ✅ Убедиться что level-system-v2 НЕ импортирует из level-system
- ✅ Проверить отсутствие relative imports к старой архитектуре
- ✅ Убедиться в корректности всех импортов из bases/configs/types

### ✅ 3.2 Проверка отсутствия хардкода
- ✅ Поиск хардкода типов: `=== 'olymp'`, `=== 'type100500'`
- ✅ Проверка что все названия берутся из `config.name`
- ✅ Убедиться что подтипы проверяются через `config.subtypes`
- ✅ Проверка что размерности берутся из `subtypeConfig.dimension`

### ✅ 3.3 Универсальность кода
- ✅ Все функции работают через `getLevelTypeConfig()`
- ✅ Новый тип добавляется ТОЛЬКО созданием конфига
- ✅ Комментарии универсальны без упоминания конкретных типов

---

## 4. JSDoc документация

### ✅ 4.1 Документирование сложных функций
- ✅ JSDoc для генераторов пейлоадов (`payloads/content/generators/`)
- ✅ JSDoc для store actions (`store/index.ts`)
- ✅ JSDoc для утилитарных функций (`configs/index.ts`)
- ✅ JSDoc для композаблов (`composables/`)

### ✅ 4.2 Документирование публичных API
- ✅ Интерфейсы и типы в `types/`
- ✅ Экспортируемые функции из `bases/`
- ✅ Конфигурационные объекты
- ✅ Компоненты с сложной логикой

---

## 5. Проверка производительности и оптимизация

### ✅ 5.1 Анализ bundle size
- ✅ Проверка размера собранного проекта
- ✅ Анализ tree-shaking для PrimeVue компонентов
- ✅ Оптимизация импортов (именованные вместо default)
- ✅ Проверка необходимости lazy loading для больших компонентов

### ✅ 5.2 Оптимизация реактивности
- ✅ Проверка использования computed vs reactive
- ✅ Оптимизация watchers (deep watching только где нужно)
- ✅ Проверка мемоизации тяжелых вычислений
- ✅ Анализ re-renders в DevTools

---

## 6. Проверка UI и UX консистентности

### ✅ 6.1 Визуальная консистентность
- ✅ Единообразие отступов и размеров во всех компонентах
- ✅ Консистентность цветовой схемы PrimeVue
- ✅ Проверка typography (размеры шрифтов, line-height)
- ✅ Единообразие иконок и их размеров

### ✅ 6.2 Responsive design
- ✅ Тестирование на мобильных устройствах (320px+)
- ✅ Проверка планшетного вида (768px+)
- ✅ Тестирование на больших экранах (1200px+)
- ✅ Корректность горизонтального скролла таблиц

---

## 7. Проверка доступности (Accessibility)

### ✅ 7.1 Keyboard navigation
- ✅ Все интерактивные элементы доступны через Tab
- ✅ Корректная последовательность фокуса
- ✅ Поддержка Enter/Space для активации кнопок
- ✅ Escape для закрытия модальных окон

### ✅ 7.2 ARIA атрибуты
- ✅ aria-label для кнопок без текста
- ✅ aria-describedby для полей с подсказками
- ✅ role атрибуты для кастомных элементов
- ✅ aria-expanded для collapsible элементов

---

## 8. Безопасность и валидация

### ✅ 8.1 XSS защита
- ✅ Проверка использования v-html (должно быть минимальным)
- ✅ Санитизация пользовательского ввода
- ✅ Валидация данных перед отправкой на сервер
- ✅ Проверка CSP заголовков

### ✅ 8.2 Валидация форм
- ✅ Проверка всех input полей на корректную валидацию
- ✅ Обработка edge cases (пустые значения, спецсимволы)
- ✅ Проверка лимитов (10000 строк, 20 символов в именах табов)
- ✅ Корректная обработка ошибок валидации

---

## 9. TypeScript coverage и типизация

### ✅ 9.1 Полнота типизации
- ✅ Отсутствие `any` типов в level-system-v2
- ✅ Корректная типизация event handlers
- ✅ Типизация всех props и emits
- ✅ Строгая типизация API responses

### ✅ 9.2 Type safety
- ✅ Проверка type guards для runtime безопасности
- ✅ Корректное использование union types
- ✅ Типизация генериков где необходимо
- ✅ Проверка строгости TypeScript конфигурации

---

## 10. Интеграционное тестирование

### ✅ 10.1 Функциональное тестирование
- ✅ Тестирование всех 5 роутов (/v2/test/olymp15|31|63|127, /v2/test/type100500)
- ✅ Проверка работы всех кнопок и контролов
- ✅ Тестирование экспорта/импорта данных
- ✅ Проверка работы с пустыми и максимальными данными

### ✅ 10.2 Взаимодействие с внешними системами
- ✅ Корректная работа с localStorage (автосохранение. На тестовых страницах загрузки вероятно не будет работать, станет доступно после полного переключения проекта на новую архитектуру)
- ✅ Правильное формирование пейлоадов для API
- ✅ Обработка ошибок сети и таймаутов
- ✅ Проверка работы LevelsModal и API запросов

---

## 11. Финальные проверки качества

### ✅ 11.1 Линтинг и сборка
- ✅ ESLint без ошибок в level-system-v2
- ✅ ESLint warnings устранены или обоснованы
- ✅ TypeScript компиляция без ошибок
- ✅ Успешная сборка проекта (npm run build)

### ✅ 11.2 Runtime проверки
- ✅ Консоль браузера без ошибок при работе с приложением
- ✅ Network tab: отсутствие лишних запросов
- ✅ Проверка памяти на утечки (DevTools Memory tab)
- ✅ Vue DevTools: корректность реактивности

## 12.1 Недоработки и проблемы (часть 1)
- ✅ В предпросмотре задания нет контента
- ✅ В типе уровня "100500" почему-то есть контролы: закрытие уровня, закрытый сектор. Хотя, по ТЗ их не должно быть (ни в конфиге, ни как следствие в контрол-панеле)
- ✅ Исправление проблемы и ошибок в рамках новой архитектуры из источников Vetur и ts-plugin (моя IDE показывает эти ошибки)

## 12.2 Недоработки и проблемы (часть 2)
- ✅ Кажется, в контрол-панели в модальном окне при нажатии кнопки "Уровни бонусов" и выборе "На выбранных уровнях" не подгружаются из Encounter, как это было в старой архитектуре
- ✅ Проверить, что выбранные уровни (в том числе "На всех уровнях") реально влияют на то, в какие уровни будут залиты бонусы (смотри реализацию в старой архитектуре и сравни с новой)
- ✅ В колонке "Уровни бонуса" в таблице DataTable кнопка "Выбрать" не работает. А также проверить условия этого поля для таблицы в старой архитектуре и перенести в новую (например, что это поле не может быть как "не выбрано". По-умолчанию: "на выбранных уровнях" с отметкой указанного уровня на шаге настроек, также можно выбрать дополнительные уровни, либо "на всех уровнях")

## 12.3 Недоработки и проблемы (часть 3)
- ✅ Проверка ESLint и TypeScript-ошибок и исправление для старой архитектуры (в ней есть файлы, которые общие с новой архитектурой, поэтому раз новая архитектура их использует - требуется проверка)
- ✅ Проверка и исправление ошибок и проблем из источника - Vetur (это не тоже самое что ESLint)

## 13.1 Улучшить (часть 1)
- ☐ Ограничить высоту контента таблицы DataTable областью экрана (сейчас стоит 600px). Надо чтобы на всю высоту экрана вмещалась как таблица (с вертикальным скроллом), так и экшн-кнопки
- ☐ Колонки в DataTable: сделать центрирование по центру (как заголовки колонок, так и содержимое ячеек)
- ☐ Убрать обертку <card></card> в LevelHeader.vue (сохранив title и subtitle в текущем виде или придумать более интересный вид, но обязательно из PrimeVue-компонентов, смотри его документацию)
- ☐ Переработать UI табов (LevelTabs), улучшить юзабилити и сделать компактнее (сейчас не очень удобно что на двух строчках, только на PrimeVue компонентах, не забывая про удобную мобильную адаптацию)
- ☐ Сделать сворачивание/разворачивание контрол-панели по кнопке (чтобы в свернутом режиме она занимала мало места на экране), желательно сохранять состояние в куках или localstorage (как проще и с меньшим количеством кода)
- ☐ Используй преимуществоенно PrimeVue и TailwindCSS, вместо кастомного html-кода и css-стилей, при необходимости изучи из документации через mcp context7
- ☐ Проверь через mcp playwright страницу /v2/test/type100500 в разных разрешениях

## 13.2 Улучшить (часть 2)
- ☐ Сделать так, чтоб при экспорте название файла состояло из: домена, id игры, номера уровня, типа уровня (с подтипом если есть)
- ☐ При успешной заливке всплывает 2 Toast-уведомления success
- ☐ В генераторе кодов по кнопке "Добавить коды" во вкладке "Генерация" добавить поле "Размер" для выбора количества знаков в коде (варианты: от 2 до 10). А также, кнопка "Сгенерировать" должна генерировать рандомные варианты, без дублей, а не по порядку как это сейчас сделано
- ☐ Убедиться что при генерации кодов не генерируются дубликаты в рамках этой генерации, а также в рамках всех табов текущей страницы загрузки (возможно такая проверка уже есть)
- ☐ В генераторе кодов по кнопке "Добавить коды" добавить функционал, а именно варианты формата:
1. `Буквенный (А-Я)`
2. `Слова (русские)` - подключить какой-нибудь большой словарь русских слов
3. `Маска` - генерирует коды по маске, при выборе дизейблится и игнорируется поле "Размер". Работают такие переменные (добавить подсказку под это поле при выборе этого варианта):
 - `слово`: любое слово из словаря русских слов
 - `(N)`: количество букв в слове из словаря русских слов (уточнение)
 - `0`: цифры. 0 - одна цифра, 00 - две цифры (а точнее уже число), 000 - три цифры (число) и т.д.
 - `я`: русские буквы. я - одна буква, яя - две буквы, яяя - три буквы и т.д.
 - `z`: английские буквы. z - одна буква, zz - две буквы, zzz - три буквы и т.д.

 Пример: `слово(3)000яяz`. Должны сгенерироваться коды, по типу таких: `рот495ыщj`.

---

## Критерии завершения

✅ **Готовность к продакшену**: Все чекбоксы отмечены
✅ **Качество кода**: ESLint + TypeScript без ошибок  
✅ **Функциональность**: Все 5 роутов работают без ошибок
✅ **Производительность**: Приемлемое время загрузки и отклика
✅ **Доступность**: Базовая поддержка a11y реализована
✅ **Безопасность**: XSS защита и валидация данных
✅ **Документация**: Сложная логика задокументирована

---

**Следующий шаг**: Шаг 32 - Улучшения UI/UX